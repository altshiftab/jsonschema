// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by keywordgen; DO NOT EDIT.

package draft202012

import (
	"cmp"

	"github.com/altshiftab/jsonschema/internal/validator"
	"github.com/altshiftab/jsonschema/pkg/types"
)

var _ = validator.ValidateTrue // avoid warning if we don't use validator below

var (
	vocabularyKeyword = types.Keyword{
		Name:      "$vocabulary",
		ArgType:   types.ArgTypeAny,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	idKeyword = types.Keyword{
		Name:      "$id",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	anchorKeyword = types.Keyword{
		Name:      "$anchor",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	dynamicAnchorKeyword = types.Keyword{
		Name:      "$dynamicAnchor",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	refKeyword = types.Keyword{
		Name:      "$ref",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ArgTypeString(validateRef),
		Generated: false,
	}

	dynamicRefKeyword = types.Keyword{
		Name:      "$dynamicRef",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ArgTypeString(validateDynamicRef),
		Generated: false,
	}

	defsKeyword = types.Keyword{
		Name:      "$defs",
		ArgType:   types.ArgTypeMapSchema,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	commentKeyword = types.Keyword{
		Name:      "$comment",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}
)

var (
	allOfKeyword = types.Keyword{
		Name:      "allOf",
		ArgType:   types.ArgTypeSchemas,
		Validate:  validator.ArgTypeSchemas(validator.ValidateAllOf),
		Generated: false,
	}

	anyOfKeyword = types.Keyword{
		Name:      "anyOf",
		ArgType:   types.ArgTypeSchemas,
		Validate:  validator.ArgTypeSchemas(validator.ValidateAnyOf),
		Generated: false,
	}

	oneOfKeyword = types.Keyword{
		Name:      "oneOf",
		ArgType:   types.ArgTypeSchemas,
		Validate:  validator.ArgTypeSchemas(validator.ValidateOneOf),
		Generated: false,
	}

	notKeyword = types.Keyword{
		Name:      "not",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateNot),
		Generated: false,
	}

	ifKeyword = types.Keyword{
		Name:      "if",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateIf),
		Generated: false,
	}

	thenKeyword = types.Keyword{
		Name:      "then",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateThen),
		Generated: false,
	}

	elseKeyword = types.Keyword{
		Name:      "else",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateElse),
		Generated: false,
	}

	dependentSchemasKeyword = types.Keyword{
		Name:      "dependentSchemas",
		ArgType:   types.ArgTypeMapSchema,
		Validate:  validator.ArgTypeMapSchema(validator.ValidateDependentSchemas),
		Generated: false,
	}

	prefixItemsKeyword = types.Keyword{
		Name:      "prefixItems",
		ArgType:   types.ArgTypeSchemas,
		Validate:  validator.ArgTypeSchemas(validator.ValidatePrefixItems),
		Generated: false,
	}

	itemsKeyword = types.Keyword{
		Name:      "items",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateItems),
		Generated: false,
	}

	containsKeyword = types.Keyword{
		Name:      "contains",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateContains),
		Generated: false,
	}

	propertiesKeyword = types.Keyword{
		Name:      "properties",
		ArgType:   types.ArgTypeMapSchema,
		Validate:  validator.ArgTypeMapSchema(validator.ValidateProperties),
		Generated: false,
	}

	patternPropertiesKeyword = types.Keyword{
		Name:      "patternProperties",
		ArgType:   types.ArgTypeMapSchema,
		Validate:  validator.ArgTypeMapSchema(validator.ValidatePatternProperties),
		Generated: false,
	}

	additionalPropertiesKeyword = types.Keyword{
		Name:      "additionalProperties",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateAdditionalProperties),
		Generated: false,
	}

	propertyNamesKeyword = types.Keyword{
		Name:      "propertyNames",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidatePropertyNames),
		Generated: false,
	}

	unevaluatedItemsKeyword = types.Keyword{
		Name:      "unevaluatedItems",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateUnevaluatedItems),
		Generated: false,
	}

	unevaluatedPropertiesKeyword = types.Keyword{
		Name:      "unevaluatedProperties",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ArgTypeSchema(validator.ValidateUnevaluatedProperties),
		Generated: false,
	}

	typeKeyword = types.Keyword{
		Name:      "type",
		ArgType:   types.ArgTypeStringOrStrings,
		Validate:  validator.ArgTypeStringOrStrings(validator.ValidateType),
		Generated: false,
	}

	enumKeyword = types.Keyword{
		Name:      "enum",
		ArgType:   types.ArgTypeAny,
		Validate:  validator.ArgTypeAny(validator.ValidateEnum),
		Generated: false,
	}

	constKeyword = types.Keyword{
		Name:      "const",
		ArgType:   types.ArgTypeAny,
		Validate:  validator.ArgTypeAny(validator.ValidateConst),
		Generated: false,
	}

	multipleOfKeyword = types.Keyword{
		Name:      "multipleOf",
		ArgType:   types.ArgTypeFloat,
		Validate:  validator.ArgTypeFloat(validator.ValidateMultipleOf),
		Generated: false,
	}

	maximumKeyword = types.Keyword{
		Name:      "maximum",
		ArgType:   types.ArgTypeFloat,
		Validate:  validator.ArgTypeFloat(validator.ValidateMaximum),
		Generated: false,
	}

	exclusiveMaximumKeyword = types.Keyword{
		Name:      "exclusiveMaximum",
		ArgType:   types.ArgTypeFloat,
		Validate:  validator.ArgTypeFloat(validator.ValidateExclusiveMaximum),
		Generated: false,
	}

	minimumKeyword = types.Keyword{
		Name:      "minimum",
		ArgType:   types.ArgTypeFloat,
		Validate:  validator.ArgTypeFloat(validator.ValidateMinimum),
		Generated: false,
	}

	exclusiveMinimumKeyword = types.Keyword{
		Name:      "exclusiveMinimum",
		ArgType:   types.ArgTypeFloat,
		Validate:  validator.ArgTypeFloat(validator.ValidateExclusiveMinimum),
		Generated: false,
	}

	maxLengthKeyword = types.Keyword{
		Name:      "maxLength",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMaxLength),
		Generated: false,
	}

	minLengthKeyword = types.Keyword{
		Name:      "minLength",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMinLength),
		Generated: false,
	}

	patternKeyword = types.Keyword{
		Name:      "pattern",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ArgTypeString(validator.ValidatePattern),
		Generated: false,
	}

	maxItemsKeyword = types.Keyword{
		Name:      "maxItems",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMaxItems),
		Generated: false,
	}

	minItemsKeyword = types.Keyword{
		Name:      "minItems",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMinItems),
		Generated: false,
	}

	uniqueItemsKeyword = types.Keyword{
		Name:      "uniqueItems",
		ArgType:   types.ArgTypeBool,
		Validate:  validator.ArgTypeBool(validator.ValidateUniqueItems),
		Generated: false,
	}

	maxContainsKeyword = types.Keyword{
		Name:      "maxContains",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMaxContains),
		Generated: false,
	}

	minContainsKeyword = types.Keyword{
		Name:      "minContains",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMinContains),
		Generated: false,
	}

	maxPropertiesKeyword = types.Keyword{
		Name:      "maxProperties",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMaxProperties),
		Generated: false,
	}

	minPropertiesKeyword = types.Keyword{
		Name:      "minProperties",
		ArgType:   types.ArgTypeInt,
		Validate:  validator.ArgTypeInt(validator.ValidateMinProperties),
		Generated: false,
	}

	requiredKeyword = types.Keyword{
		Name:      "required",
		ArgType:   types.ArgTypeStrings,
		Validate:  validator.ArgTypeStrings(validator.ValidateRequired),
		Generated: false,
	}

	dependentRequiredKeyword = types.Keyword{
		Name:      "dependentRequired",
		ArgType:   types.ArgTypeAny,
		Validate:  validator.ArgTypeAny(validator.ValidateDependentRequired),
		Generated: false,
	}

	formatKeyword = types.Keyword{
		Name:      "format",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ArgTypeString(validator.ValidateFormat),
		Generated: false,
	}

	contentEncodingKeyword = types.Keyword{
		Name:      "contentEncoding",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	contentMediaTypeKeyword = types.Keyword{
		Name:      "contentMediaType",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	contentSchemaKeyword = types.Keyword{
		Name:      "contentSchema",
		ArgType:   types.ArgTypeSchema,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	titleKeyword = types.Keyword{
		Name:      "title",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	descriptionKeyword = types.Keyword{
		Name:      "description",
		ArgType:   types.ArgTypeString,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	defaultKeyword = types.Keyword{
		Name:      "default",
		ArgType:   types.ArgTypeAny,
		Validate:  validator.ArgTypeAny(validator.ValidateDefault),
		Generated: false,
	}

	deprecatedKeyword = types.Keyword{
		Name:      "deprecated",
		ArgType:   types.ArgTypeBool,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	readOnlyKeyword = types.Keyword{
		Name:      "readOnly",
		ArgType:   types.ArgTypeBool,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	writeOnlyKeyword = types.Keyword{
		Name:      "writeOnly",
		ArgType:   types.ArgTypeBool,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	examplesKeyword = types.Keyword{
		Name:      "examples",
		ArgType:   types.ArgTypeAny,
		Validate:  validator.ValidateTrue,
		Generated: false,
	}

	dependenciesKeyword = types.Keyword{
		Name:      "dependencies",
		ArgType:   types.ArgTypeMapArrayOrSchema,
		Validate:  validator.ArgTypeMapArrayOrSchema(validator.ValidateDependencies),
		Generated: false,
	}
)

// keywordMap maps keyword names to [types.Keyword] values.
var keywordMap = map[string]*types.Keyword{
	"$vocabulary":           &vocabularyKeyword,
	"$id":                   &idKeyword,
	"$anchor":               &anchorKeyword,
	"$dynamicAnchor":        &dynamicAnchorKeyword,
	"$ref":                  &refKeyword,
	"$dynamicRef":           &dynamicRefKeyword,
	"$defs":                 &defsKeyword,
	"$comment":              &commentKeyword,
	"allOf":                 &allOfKeyword,
	"anyOf":                 &anyOfKeyword,
	"oneOf":                 &oneOfKeyword,
	"not":                   &notKeyword,
	"if":                    &ifKeyword,
	"then":                  &thenKeyword,
	"else":                  &elseKeyword,
	"dependentSchemas":      &dependentSchemasKeyword,
	"prefixItems":           &prefixItemsKeyword,
	"items":                 &itemsKeyword,
	"contains":              &containsKeyword,
	"properties":            &propertiesKeyword,
	"patternProperties":     &patternPropertiesKeyword,
	"additionalProperties":  &additionalPropertiesKeyword,
	"propertyNames":         &propertyNamesKeyword,
	"unevaluatedItems":      &unevaluatedItemsKeyword,
	"unevaluatedProperties": &unevaluatedPropertiesKeyword,
	"type":                  &typeKeyword,
	"enum":                  &enumKeyword,
	"const":                 &constKeyword,
	"multipleOf":            &multipleOfKeyword,
	"maximum":               &maximumKeyword,
	"exclusiveMaximum":      &exclusiveMaximumKeyword,
	"minimum":               &minimumKeyword,
	"exclusiveMinimum":      &exclusiveMinimumKeyword,
	"maxLength":             &maxLengthKeyword,
	"minLength":             &minLengthKeyword,
	"pattern":               &patternKeyword,
	"maxItems":              &maxItemsKeyword,
	"minItems":              &minItemsKeyword,
	"uniqueItems":           &uniqueItemsKeyword,
	"maxContains":           &maxContainsKeyword,
	"minContains":           &minContainsKeyword,
	"maxProperties":         &maxPropertiesKeyword,
	"minProperties":         &minPropertiesKeyword,
	"required":              &requiredKeyword,
	"dependentRequired":     &dependentRequiredKeyword,
	"format":                &formatKeyword,
	"contentEncoding":       &contentEncodingKeyword,
	"contentMediaType":      &contentMediaTypeKeyword,
	"contentSchema":         &contentSchemaKeyword,
	"title":                 &titleKeyword,
	"description":           &descriptionKeyword,
	"default":               &defaultKeyword,
	"deprecated":            &deprecatedKeyword,
	"readOnly":              &readOnlyKeyword,
	"writeOnly":             &writeOnlyKeyword,
	"examples":              &examplesKeyword,
	"dependencies":          &dependenciesKeyword,
}

// AddBool adds a keyword with an argument of type Bool.
func (b *Builder) AddBool(keyword *types.Keyword, v bool) *Builder {
	b.b = b.b.AddBool(keyword, v)
	return b
}

// AddString adds a keyword with an argument of type String.
func (b *Builder) AddString(keyword *types.Keyword, v string) *Builder {
	b.b = b.b.AddString(keyword, v)
	return b
}

// AddStrings adds a keyword with an argument of type Strings.
func (b *Builder) AddStrings(keyword *types.Keyword, v []string) *Builder {
	b.b = b.b.AddStrings(keyword, v)
	return b
}

// AddInt adds a keyword with an argument of type Int.
func (b *Builder) AddInt(keyword *types.Keyword, v int64) *Builder {
	b.b = b.b.AddInt(keyword, v)
	return b
}

// AddFloat adds a keyword with an argument of type Float.
func (b *Builder) AddFloat(keyword *types.Keyword, v float64) *Builder {
	b.b = b.b.AddFloat(keyword, v)
	return b
}

// AddSchema adds a keyword with an argument of type Schema.
func (b *Builder) AddSchema(keyword *types.Keyword, v *types.Schema) *Builder {
	b.b = b.b.AddSchema(keyword, v)
	return b
}

// AddSchemas adds a keyword with an argument of type Schemas.
func (b *Builder) AddSchemas(keyword *types.Keyword, v []*types.Schema) *Builder {
	b.b = b.b.AddSchemas(keyword, v)
	return b
}

// AddMapSchema adds a keyword with an argument of type MapSchema.
func (b *Builder) AddMapSchema(keyword *types.Keyword, v map[string]*types.Schema) *Builder {
	b.b = b.b.AddMapSchema(keyword, v)
	return b
}

// AddSchemaOrSchemas adds a keyword with an argument of type SchemaOrSchemas.
func (b *Builder) AddSchemaOrSchemas(keyword *types.Keyword, v types.PartSchemaOrSchemas) *Builder {
	b.b = b.b.AddSchemaOrSchemas(keyword, v)
	return b
}

// AddMapArrayOrSchema adds a keyword with an argument of type MapArrayOrSchema.
func (b *Builder) AddMapArrayOrSchema(keyword *types.Keyword, v map[string]types.ArrayOrSchema) *Builder {
	b.b = b.b.AddMapArrayOrSchema(keyword, v)
	return b
}

// AddAny adds a keyword with an argument of type Any.
func (b *Builder) AddAny(keyword *types.Keyword, v any) *Builder {
	b.b = b.b.AddAny(keyword, v)
	return b
}

// AddComment adds the $comment keyword to the schema.
func (b *Builder) AddComment(arg string) *Builder {
	return b.AddString(&commentKeyword, arg)
}

// AddAllOf adds the allOf keyword to the schema.
func (b *Builder) AddAllOf(arg []*types.Schema) *Builder {
	return b.AddSchemas(&allOfKeyword, arg)
}

// AddAnyOf adds the anyOf keyword to the schema.
func (b *Builder) AddAnyOf(arg []*types.Schema) *Builder {
	return b.AddSchemas(&anyOfKeyword, arg)
}

// AddOneOf adds the oneOf keyword to the schema.
func (b *Builder) AddOneOf(arg []*types.Schema) *Builder {
	return b.AddSchemas(&oneOfKeyword, arg)
}

// AddNot adds the not keyword to the schema.
func (b *Builder) AddNot(arg *types.Schema) *Builder {
	return b.AddSchema(&notKeyword, arg)
}

// AddIf adds the if keyword to the schema.
func (b *Builder) AddIf(arg *types.Schema) *Builder {
	return b.AddSchema(&ifKeyword, arg)
}

// AddThen adds the then keyword to the schema.
func (b *Builder) AddThen(arg *types.Schema) *Builder {
	return b.AddSchema(&thenKeyword, arg)
}

// AddElse adds the else keyword to the schema.
func (b *Builder) AddElse(arg *types.Schema) *Builder {
	return b.AddSchema(&elseKeyword, arg)
}

// AddDependentSchemas adds the dependentSchemas keyword to the schema.
func (b *Builder) AddDependentSchemas(arg map[string]*types.Schema) *Builder {
	return b.AddMapSchema(&dependentSchemasKeyword, arg)
}

// AddPrefixItems adds the prefixItems keyword to the schema.
func (b *Builder) AddPrefixItems(arg []*types.Schema) *Builder {
	return b.AddSchemas(&prefixItemsKeyword, arg)
}

// AddItems adds the items keyword to the schema.
func (b *Builder) AddItems(arg *types.Schema) *Builder {
	return b.AddSchema(&itemsKeyword, arg)
}

// AddContains adds the contains keyword to the schema.
func (b *Builder) AddContains(arg *types.Schema) *Builder {
	return b.AddSchema(&containsKeyword, arg)
}

// AddProperties adds the properties keyword to the schema.
func (b *Builder) AddProperties(arg map[string]*types.Schema) *Builder {
	return b.AddMapSchema(&propertiesKeyword, arg)
}

// AddPatternProperties adds the patternProperties keyword to the schema.
func (b *Builder) AddPatternProperties(arg map[string]*types.Schema) *Builder {
	return b.AddMapSchema(&patternPropertiesKeyword, arg)
}

// AddAdditionalProperties adds the additionalProperties keyword to the schema.
func (b *Builder) AddAdditionalProperties(arg *types.Schema) *Builder {
	return b.AddSchema(&additionalPropertiesKeyword, arg)
}

// AddPropertyNames adds the propertyNames keyword to the schema.
func (b *Builder) AddPropertyNames(arg *types.Schema) *Builder {
	return b.AddSchema(&propertyNamesKeyword, arg)
}

// AddUnevaluatedItems adds the unevaluatedItems keyword to the schema.
func (b *Builder) AddUnevaluatedItems(arg *types.Schema) *Builder {
	return b.AddSchema(&unevaluatedItemsKeyword, arg)
}

// AddUnevaluatedProperties adds the unevaluatedProperties keyword to the schema.
func (b *Builder) AddUnevaluatedProperties(arg *types.Schema) *Builder {
	return b.AddSchema(&unevaluatedPropertiesKeyword, arg)
}

// AddType adds the type keyword with one or more strings to the schema.
func (b *Builder) AddType(args ...string) *Builder {
	if len(args) == 1 {
		return b.AddString(&typeKeyword, args[0])
	} else {
		return b.AddStrings(&typeKeyword, args)
	}
}

// AddEnum adds the enum keyword to the schema.
func (b *Builder) AddEnum(arg any) *Builder {
	return b.AddAny(&enumKeyword, arg)
}

// AddConst adds the const keyword to the schema.
func (b *Builder) AddConst(arg any) *Builder {
	return b.AddAny(&constKeyword, arg)
}

// AddMultipleOf adds the multipleOf keyword to the schema.
func (b *Builder) AddMultipleOf(arg float64) *Builder {
	return b.AddFloat(&multipleOfKeyword, arg)
}

// AddMaximum adds the maximum keyword to the schema.
func (b *Builder) AddMaximum(arg float64) *Builder {
	return b.AddFloat(&maximumKeyword, arg)
}

// AddExclusiveMaximum adds the exclusiveMaximum keyword to the schema.
func (b *Builder) AddExclusiveMaximum(arg float64) *Builder {
	return b.AddFloat(&exclusiveMaximumKeyword, arg)
}

// AddMinimum adds the minimum keyword to the schema.
func (b *Builder) AddMinimum(arg float64) *Builder {
	return b.AddFloat(&minimumKeyword, arg)
}

// AddExclusiveMinimum adds the exclusiveMinimum keyword to the schema.
func (b *Builder) AddExclusiveMinimum(arg float64) *Builder {
	return b.AddFloat(&exclusiveMinimumKeyword, arg)
}

// AddMaxLength adds the maxLength keyword to the schema.
func (b *Builder) AddMaxLength(arg int64) *Builder {
	return b.AddInt(&maxLengthKeyword, arg)
}

// AddMinLength adds the minLength keyword to the schema.
func (b *Builder) AddMinLength(arg int64) *Builder {
	return b.AddInt(&minLengthKeyword, arg)
}

// AddPattern adds the pattern keyword to the schema.
func (b *Builder) AddPattern(arg string) *Builder {
	return b.AddString(&patternKeyword, arg)
}

// AddMaxItems adds the maxItems keyword to the schema.
func (b *Builder) AddMaxItems(arg int64) *Builder {
	return b.AddInt(&maxItemsKeyword, arg)
}

// AddMinItems adds the minItems keyword to the schema.
func (b *Builder) AddMinItems(arg int64) *Builder {
	return b.AddInt(&minItemsKeyword, arg)
}

// AddUniqueItems adds the uniqueItems keyword to the schema.
func (b *Builder) AddUniqueItems(arg bool) *Builder {
	return b.AddBool(&uniqueItemsKeyword, arg)
}

// AddMaxContains adds the maxContains keyword to the schema.
func (b *Builder) AddMaxContains(arg int64) *Builder {
	return b.AddInt(&maxContainsKeyword, arg)
}

// AddMinContains adds the minContains keyword to the schema.
func (b *Builder) AddMinContains(arg int64) *Builder {
	return b.AddInt(&minContainsKeyword, arg)
}

// AddMaxProperties adds the maxProperties keyword to the schema.
func (b *Builder) AddMaxProperties(arg int64) *Builder {
	return b.AddInt(&maxPropertiesKeyword, arg)
}

// AddMinProperties adds the minProperties keyword to the schema.
func (b *Builder) AddMinProperties(arg int64) *Builder {
	return b.AddInt(&minPropertiesKeyword, arg)
}

// AddRequired adds the required keyword to the schema.
func (b *Builder) AddRequired(arg []string) *Builder {
	return b.AddStrings(&requiredKeyword, arg)
}

// AddDependentRequired adds the dependentRequired keyword to the schema.
func (b *Builder) AddDependentRequired(arg any) *Builder {
	return b.AddAny(&dependentRequiredKeyword, arg)
}

// AddFormat adds the format keyword to the schema.
func (b *Builder) AddFormat(arg string) *Builder {
	return b.AddString(&formatKeyword, arg)
}

// AddContentEncoding adds the contentEncoding keyword to the schema.
func (b *Builder) AddContentEncoding(arg string) *Builder {
	return b.AddString(&contentEncodingKeyword, arg)
}

// AddContentMediaType adds the contentMediaType keyword to the schema.
func (b *Builder) AddContentMediaType(arg string) *Builder {
	return b.AddString(&contentMediaTypeKeyword, arg)
}

// AddContentSchema adds the contentSchema keyword to the schema.
func (b *Builder) AddContentSchema(arg *types.Schema) *Builder {
	return b.AddSchema(&contentSchemaKeyword, arg)
}

// AddTitle adds the title keyword to the schema.
func (b *Builder) AddTitle(arg string) *Builder {
	return b.AddString(&titleKeyword, arg)
}

// AddDescription adds the description keyword to the schema.
func (b *Builder) AddDescription(arg string) *Builder {
	return b.AddString(&descriptionKeyword, arg)
}

// AddDefault adds the default keyword to the schema.
func (b *Builder) AddDefault(arg any) *Builder {
	return b.AddAny(&defaultKeyword, arg)
}

// AddDeprecated adds the deprecated keyword to the schema.
func (b *Builder) AddDeprecated(arg bool) *Builder {
	return b.AddBool(&deprecatedKeyword, arg)
}

// AddReadOnly adds the readOnly keyword to the schema.
func (b *Builder) AddReadOnly(arg bool) *Builder {
	return b.AddBool(&readOnlyKeyword, arg)
}

// AddWriteOnly adds the writeOnly keyword to the schema.
func (b *Builder) AddWriteOnly(arg bool) *Builder {
	return b.AddBool(&writeOnlyKeyword, arg)
}

// AddExamples adds the examples keyword to the schema.
func (b *Builder) AddExamples(arg any) *Builder {
	return b.AddAny(&examplesKeyword, arg)
}

// AddDependencies adds the dependencies keyword to the schema.
func (b *Builder) AddDependencies(arg map[string]types.ArrayOrSchema) *Builder {
	return b.AddMapArrayOrSchema(&dependenciesKeyword, arg)
}

// sortRank is the ranking of each keyword when sorting
var sortRank = map[string]int{
	"$comment":              0,
	"$id":                   1,
	"$anchor":               2,
	"$defs":                 3,
	"$dynamicAnchor":        4,
	"$dynamicRef":           5,
	"$ref":                  6,
	"$vocabulary":           7,
	"allOf":                 8,
	"anyOf":                 9,
	"const":                 10,
	"contains":              11,
	"contentEncoding":       12,
	"contentMediaType":      13,
	"contentSchema":         14,
	"default":               15,
	"dependencies":          16,
	"dependentRequired":     17,
	"dependentSchemas":      18,
	"deprecated":            19,
	"description":           20,
	"enum":                  21,
	"examples":              22,
	"exclusiveMaximum":      23,
	"exclusiveMinimum":      24,
	"format":                25,
	"if":                    26,
	"maxContains":           27,
	"maxItems":              28,
	"maxLength":             29,
	"maxProperties":         30,
	"maximum":               31,
	"minContains":           32,
	"minItems":              33,
	"minLength":             34,
	"minProperties":         35,
	"minimum":               36,
	"multipleOf":            37,
	"not":                   38,
	"oneOf":                 39,
	"pattern":               40,
	"patternProperties":     41,
	"prefixItems":           42,
	"items":                 43,
	"properties":            44,
	"additionalProperties":  45,
	"propertyNames":         46,
	"readOnly":              47,
	"required":              48,
	"then":                  49,
	"else":                  50,
	"title":                 51,
	"type":                  52,
	"unevaluatedItems":      53,
	"unevaluatedProperties": 54,
	"uniqueItems":           55,
	"writeOnly":             56,
}

// keywordCmp is the keyword comparison routine.
func keywordCmp(a, b string) int {
	return cmp.Compare(sortRank[a], sortRank[b])
}
