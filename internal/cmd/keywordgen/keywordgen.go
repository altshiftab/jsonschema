// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// keywordgen generates repetitive code for JSON schema keywords.
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"
)

// packageName is the name of the package to use in the generated file.
var packageName = flag.String("p", "", "package name in generated code")

// output is the name of the output file to generate.
var output = flag.String("o", "", "output file name")

// usage prints usage information.
func usage() {
	fmt.Fprintln(os.Stderr, "Usage of keywordgen:")
	fmt.Fprintln(os.Stderr, "\tkeywordgen [flags] keyword1.json keyword2.json...")
	fmt.Fprintln(os.Stderr, "Flags:")
	flag.PrintDefaults()
}

// header is the overall file header.
const header = `// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by keywordgen; DO NOT EDIT.

package %s

import (
	"cmp"

	"github.com/ianlancetaylor/jsonschema/pkg/types"
	"github.com/ianlancetaylor/jsonschema/internal/validator"
)

var _  = validator.ValidateTrue // avoid warning if we don't use validator below

`

func main() {
	flag.Usage = usage
	flag.Parse()
	if *packageName == "" {
		fmt.Fprintln(os.Stderr, "missing required option -p PACKAGENAME")
		usage()
		os.Exit(2)
	}
	if *output == "" {
		fmt.Fprintln(os.Stderr, "missing required option -o OUTPUT")
		usage()
		os.Exit(2)
	}

	if len(flag.Args()) < 1 {
		fmt.Fprintln(os.Stderr, "no input files")
		usage()
		os.Exit(2)
	}

	buf := new(bytes.Buffer)

	fmt.Fprintf(buf, header, *packageName)

	mapBuf := new(bytes.Buffer)
	fmt.Fprintln(mapBuf, "// keywordMap maps keyword names to [types.Keyword] values.")
	fmt.Fprintln(mapBuf, "var keywordMap = map[string]*types.Keyword{")

	builderBuf := new(bytes.Buffer)
	writeBuilderHeader(builderBuf)

	var kd []keywordData

	for i, arg := range flag.Args() {
		if i > 0 {
			fmt.Fprintln(buf)
		}
		keywords := readKeywords(arg)
		printKeywords(buf, keywords)
		printKeywordsMap(mapBuf, keywords)
		printKeywordsBuilder(builderBuf, keywords)
		kd = append(kd, keywords.Keywords...)
	}

	fmt.Fprintln(mapBuf, "}")

	fmt.Fprintln(buf)

	if _, err := io.Copy(buf, mapBuf); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	fmt.Fprintln(buf)

	if _, err := io.Copy(buf, builderBuf); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	fmt.Fprintln(buf)
	printKeywordsSort(buf, kd)

	writeOutput(buf)
}

// keywordsData is the JSON format that describes the keywords.
type keywordsData struct {
	// The name of this group of keywords; fairly arbitrary.
	Name string `json:"name"`
	// The description of this group of keywords, not currently used.
	Description string `json:"description"`
	// The number of characters to skip in the keyword name
	// to form an identifier; 1 for a group that contains
	// keywords that start with '$'.
	Prefix int `json:"prefix,omitempty"`
	// The actual keywords in this group.
	Keywords []keywordData `json:"keywords"`
}

// keywordData is the JSON format that describes a single keyword.
type keywordData struct {
	// Keyword name: $id, allOf, ....
	Name string `json:"name"`
	// Argument type of keyword: string, int, schema, ....
	ArgType string `json:"argType"`
	// Whether the keyword is always valid,
	// in which case it does not need a validation function.
	AlwaysValid bool `json:"alwaysValid,omitempty"`
	// The name of the validator function.
	// The default is validator.ValidateNAME.
	Validator string `json:"validator,omitempty"`
	// Whether to skip adding a Builder method for this keyword.
	SkipBuilder bool `json:"skipBuilder,omitempty"`
	// An optional comment for the Builder method.
	BuilderComment string `json:"builderComment,omitempty"`
	// If present, a list of keywords that this keyword should follow.
	// This is used to sort the keywords in an instance of a schema.
	After []string `json:"after,omitempty"`
}

// readKeywords reads a JSON file describing the keywords.
func readKeywords(name string) *keywordsData {
	f, err := os.Open(name)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer f.Close()

	var ret keywordsData
	if err := json.NewDecoder(f).Decode(&ret); err != nil {
		if se, ok := err.(*json.SyntaxError); ok {
			fmt.Fprintf(os.Stderr, "%s: %d: %v\n", name, se.Offset, err)
		} else {
			fmt.Fprintf(os.Stderr, "%s: %v\n", name, err)
		}
		os.Exit(1)
	}

	return &ret
}

// printKeywords prints the definitions for a group of keywords.
func printKeywords(buf *bytes.Buffer, keywords *keywordsData) {
	fmt.Fprintln(buf, "var (")
	for i, k := range keywords.Keywords {
		if i > 0 {
			fmt.Fprintln(buf)
		}
		fmt.Fprintf(buf, "\t%sKeyword = types.Keyword{\n", k.Name[keywords.Prefix:])
		fmt.Fprintf(buf, "\t\tName: %q,\n", k.Name)
		fmt.Fprintf(buf, "\t\tArgType: types.ArgType%s,\n", oneup(k.ArgType))
		fmt.Fprintf(buf, "\t\tValidate: %s,\n", validateFunction(k, keywords.Prefix))
		fmt.Fprintf(buf, "\t\tGenerated: false,\n")
		fmt.Fprintln(buf, "\t}")
	}
	fmt.Fprintln(buf, ")")
}

// printKeywordsMap prints the entries for the keyword map.
func printKeywordsMap(mapBuf *bytes.Buffer, keywords *keywordsData) {
	for _, k := range keywords.Keywords {
		fmt.Fprintf(mapBuf, "\t%q: &%sKeyword,\n", k.Name, k.Name[keywords.Prefix:])
	}
}

// validateFunction returns an expression for the validation function for k.
// The expression uses a wrapper to parse the argument based on the type.
func validateFunction(k keywordData, prefix int) string {
	if k.AlwaysValid {
		return "validator.ValidateTrue"
	}
	name := k.Validator
	if name == "" {
		name = "validator.Validate" + oneup(k.Name[prefix:])
	}
	return fmt.Sprintf("validator.ArgType%s(%s)", oneup(k.ArgType), name)
}

// oneup returns the string with the first character converted to uppercase.
func oneup(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

// writeOutput writes buf to the output file.
func writeOutput(buf *bytes.Buffer) {
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: error formatting source: %v\n", os.Args[0], err)
		fmt.Fprintf(os.Stderr, "%s", buf.Bytes())
		os.Exit(1)
	}
	if err := os.WriteFile(*output, formatted, 0o644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
