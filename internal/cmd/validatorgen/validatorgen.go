// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// validatorgen generates validator functions for different
// schema argument types.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"

	"github.com/altshiftab/jsonschema/internal/argtype"
	"github.com/altshiftab/jsonschema/pkg/types/arg_type"
)

type keyword struct {
	name        string
	argType     arg_type.ArgType
	alwaysValid bool
}

const header = `// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by validatorgen; DO NOT EDIT.

package validator

import (
	"fmt"

	"github.com/ianlancetaylor/jsonschema/pkg/types"
)
`

func main() {
	printValidatorConvertors()
}

// validatorFn is the template for a validator function.
// %[1] is the schema argument type.
// %[2] is the function name.
const validatorFn = `// %[2]s converts a validator function that accepts
// [types.ArgType%[1]s] to one that can be stored in a [types.Keyword].
func %[2]s(fn func(arg types.Part%[1]s, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := To%[1]s(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}`

// convertorFn is the template for a convertor function.
// %[1] is the schema argument type.
// %[2] is a description for an error message.
const convertorFn = `// To%[1]s converts arg into a [types.Part%[1]s].
func To%[1]s(arg types.PartValue) (types.Part%[1]s, error) {
	v, ok := arg.(types.Part%[1]s)
	if !ok {
		var zero types.Part%[1]s
		return zero, fmt.Errorf("got %%T, expect %[2]s", arg)
	}
	return v, nil
}`

// printValidatorConvertors writes out the validation conversion functions.
// These are functions that take a value of type any,
// verify that the value is of the right type,
// and then invoke the real validation function.
// This lets us write the validation functions with the correct type,
// without having to worry about always type checking.
func printValidatorConvertors() {
	buf := new(bytes.Buffer)

	fmt.Fprint(buf, header)
	fmt.Fprintln(buf)

	for t := arg_type.ArgTypeBool; t <= arg_type.ArgTypeAny; t++ {
		tn := argtype.Name(t)
		name := "ArgType" + tn
		fmt.Fprintln(buf)
		fmt.Fprintf(buf, validatorFn, tn, name)

		// For numbers we need to accept multiple possibilities,
		// so those convertors are written by hand.
		if t == arg_type.ArgTypeInt || t == arg_type.ArgTypeFloat {
			continue
		}

		var desc string
		switch t {
		case arg_type.ArgTypeBool:
			desc = "bool"
		case arg_type.ArgTypeString:
			desc = "a string"
		case arg_type.ArgTypeStrings:
			desc = "an array of strings"
		case arg_type.ArgTypeStringOrStrings:
			desc = "a string or an array of strings"
		case arg_type.ArgTypeSchema:
			desc = "a schema"
		case arg_type.ArgTypeSchemas:
			desc = "an array of schemas"
		case arg_type.ArgTypeMapSchema:
			desc = "a mapping from strings to schemas"
		case arg_type.ArgTypeSchemaOrSchemas:
			desc = "a single schema or an array of schemas"
		case arg_type.ArgTypeMapArrayOrSchema:
			desc = "a mapping from strings to either a schema or an array of strings"
		case arg_type.ArgTypeAny:
			desc = "any type"
		default:
			panic("can't happen")
		}

		fmt.Fprintln(buf)
		fmt.Fprintf(buf, convertorFn, tn, desc)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	if err := os.WriteFile("validators.go", formatted, 0o644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
