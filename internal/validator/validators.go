// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by validatorgen; DO NOT EDIT.

package validator

import (
	"fmt"

	"github.com/altshiftab/jsonschema/pkg/types/schema"
)

// ArgTypeBool converts a validator function that accepts
// [types.ArgTypeBool] to one that can be stored in a [types.Keyword].
func ArgTypeBool(fn func(arg schema.PartBool, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToBool(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToBool converts arg into a [types.PartBool].
func ToBool(arg schema.PartValue) (schema.PartBool, error) {
	v, ok := arg.(schema.PartBool)
	if !ok {
		var zero schema.PartBool
		return zero, fmt.Errorf("got %T, expect bool", arg)
	}
	return v, nil
}

// ArgTypeString converts a validator function that accepts
// [types.ArgTypeString] to one that can be stored in a [types.Keyword].
func ArgTypeString(fn func(arg schema.PartString, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToString(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToString converts arg into a [types.PartString].
func ToString(arg schema.PartValue) (schema.PartString, error) {
	v, ok := arg.(schema.PartString)
	if !ok {
		var zero schema.PartString
		return zero, fmt.Errorf("got %T, expect a string", arg)
	}
	return v, nil
}

// ArgTypeStrings converts a validator function that accepts
// [types.ArgTypeStrings] to one that can be stored in a [types.Keyword].
func ArgTypeStrings(fn func(arg schema.PartStrings, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToStrings(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToStrings converts arg into a [types.PartStrings].
func ToStrings(arg schema.PartValue) (schema.PartStrings, error) {
	v, ok := arg.(schema.PartStrings)
	if !ok {
		var zero schema.PartStrings
		return zero, fmt.Errorf("got %T, expect an array of strings", arg)
	}
	return v, nil
}

// ArgTypeStringOrStrings converts a validator function that accepts
// [types.ArgTypeStringOrStrings] to one that can be stored in a [types.Keyword].
func ArgTypeStringOrStrings(fn func(arg schema.PartStringOrStrings, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToStringOrStrings(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToStringOrStrings converts arg into a [types.PartStringOrStrings].
func ToStringOrStrings(arg schema.PartValue) (schema.PartStringOrStrings, error) {
	v, ok := arg.(schema.PartStringOrStrings)
	if !ok {
		var zero schema.PartStringOrStrings
		return zero, fmt.Errorf("got %T, expect a string or an array of strings", arg)
	}
	return v, nil
}

// ArgTypeInt converts a validator function that accepts
// [types.ArgTypeInt] to one that can be stored in a [types.Keyword].
func ArgTypeInt(fn func(arg schema.PartInt, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToInt(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ArgTypeFloat converts a validator function that accepts
// [types.ArgTypeFloat] to one that can be stored in a [types.Keyword].
func ArgTypeFloat(fn func(arg schema.PartFloat, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToFloat(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ArgTypeSchema converts a validator function that accepts
// [types.ArgTypeSchema] to one that can be stored in a [types.Keyword].
func ArgTypeSchema(fn func(arg schema.PartSchema, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToSchema(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToSchema converts arg into a [types.PartSchema].
func ToSchema(arg schema.PartValue) (schema.PartSchema, error) {
	v, ok := arg.(schema.PartSchema)
	if !ok {
		var zero schema.PartSchema
		return zero, fmt.Errorf("got %T, expect a schema", arg)
	}
	return v, nil
}

// ArgTypeSchemas converts a validator function that accepts
// [types.ArgTypeSchemas] to one that can be stored in a [types.Keyword].
func ArgTypeSchemas(fn func(arg schema.PartSchemas, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToSchemas(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToSchemas converts arg into a [types.PartSchemas].
func ToSchemas(arg schema.PartValue) (schema.PartSchemas, error) {
	v, ok := arg.(schema.PartSchemas)
	if !ok {
		var zero schema.PartSchemas
		return zero, fmt.Errorf("got %T, expect an array of schemas", arg)
	}
	return v, nil
}

// ArgTypeMapSchema converts a validator function that accepts
// [types.ArgTypeMapSchema] to one that can be stored in a [types.Keyword].
func ArgTypeMapSchema(fn func(arg schema.PartMapSchema, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToMapSchema(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToMapSchema converts arg into a [types.PartMapSchema].
func ToMapSchema(arg schema.PartValue) (schema.PartMapSchema, error) {
	v, ok := arg.(schema.PartMapSchema)
	if !ok {
		var zero schema.PartMapSchema
		return zero, fmt.Errorf("got %T, expect a mapping from strings to schemas", arg)
	}
	return v, nil
}

// ArgTypeSchemaOrSchemas converts a validator function that accepts
// [types.ArgTypeSchemaOrSchemas] to one that can be stored in a [types.Keyword].
func ArgTypeSchemaOrSchemas(fn func(arg schema.PartSchemaOrSchemas, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToSchemaOrSchemas(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToSchemaOrSchemas converts arg into a [types.PartSchemaOrSchemas].
func ToSchemaOrSchemas(arg schema.PartValue) (schema.PartSchemaOrSchemas, error) {
	v, ok := arg.(schema.PartSchemaOrSchemas)
	if !ok {
		var zero schema.PartSchemaOrSchemas
		return zero, fmt.Errorf("got %T, expect a single schema or an array of schemas", arg)
	}
	return v, nil
}

// ArgTypeMapArrayOrSchema converts a validator function that accepts
// [types.ArgTypeMapArrayOrSchema] to one that can be stored in a [types.Keyword].
func ArgTypeMapArrayOrSchema(fn func(arg schema.PartMapArrayOrSchema, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToMapArrayOrSchema(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToMapArrayOrSchema converts arg into a [types.PartMapArrayOrSchema].
func ToMapArrayOrSchema(arg schema.PartValue) (schema.PartMapArrayOrSchema, error) {
	v, ok := arg.(schema.PartMapArrayOrSchema)
	if !ok {
		var zero schema.PartMapArrayOrSchema
		return zero, fmt.Errorf("got %T, expect a mapping from strings to either a schema or an array of strings", arg)
	}
	return v, nil
}

// ArgTypeAny converts a validator function that accepts
// [types.ArgTypeAny] to one that can be stored in a [types.Keyword].
func ArgTypeAny(fn func(arg schema.PartAny, instance any, state *schema.ValidationState) error) func(schema.PartValue, any, *schema.ValidationState) error {
	return func(arg schema.PartValue, instance any, state *schema.ValidationState) error {
		v, err := ToAny(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToAny converts arg into a [types.PartAny].
func ToAny(arg schema.PartValue) (schema.PartAny, error) {
	v, ok := arg.(schema.PartAny)
	if !ok {
		var zero schema.PartAny
		return zero, fmt.Errorf("got %T, expect any type", arg)
	}
	return v, nil
}
