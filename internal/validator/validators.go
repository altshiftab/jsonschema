// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by validatorgen; DO NOT EDIT.

package validator

import (
	"fmt"

	"github.com/altshiftab/jsonschema/pkg/types"
)

// ArgTypeBool converts a validator function that accepts
// [types.ArgTypeBool] to one that can be stored in a [types.Keyword].
func ArgTypeBool(fn func(arg types.PartBool, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToBool(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToBool converts arg into a [types.PartBool].
func ToBool(arg types.PartValue) (types.PartBool, error) {
	v, ok := arg.(types.PartBool)
	if !ok {
		var zero types.PartBool
		return zero, fmt.Errorf("got %T, expect bool", arg)
	}
	return v, nil
}

// ArgTypeString converts a validator function that accepts
// [types.ArgTypeString] to one that can be stored in a [types.Keyword].
func ArgTypeString(fn func(arg types.PartString, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToString(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToString converts arg into a [types.PartString].
func ToString(arg types.PartValue) (types.PartString, error) {
	v, ok := arg.(types.PartString)
	if !ok {
		var zero types.PartString
		return zero, fmt.Errorf("got %T, expect a string", arg)
	}
	return v, nil
}

// ArgTypeStrings converts a validator function that accepts
// [types.ArgTypeStrings] to one that can be stored in a [types.Keyword].
func ArgTypeStrings(fn func(arg types.PartStrings, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToStrings(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToStrings converts arg into a [types.PartStrings].
func ToStrings(arg types.PartValue) (types.PartStrings, error) {
	v, ok := arg.(types.PartStrings)
	if !ok {
		var zero types.PartStrings
		return zero, fmt.Errorf("got %T, expect an array of strings", arg)
	}
	return v, nil
}

// ArgTypeStringOrStrings converts a validator function that accepts
// [types.ArgTypeStringOrStrings] to one that can be stored in a [types.Keyword].
func ArgTypeStringOrStrings(fn func(arg types.PartStringOrStrings, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToStringOrStrings(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToStringOrStrings converts arg into a [types.PartStringOrStrings].
func ToStringOrStrings(arg types.PartValue) (types.PartStringOrStrings, error) {
	v, ok := arg.(types.PartStringOrStrings)
	if !ok {
		var zero types.PartStringOrStrings
		return zero, fmt.Errorf("got %T, expect a string or an array of strings", arg)
	}
	return v, nil
}

// ArgTypeInt converts a validator function that accepts
// [types.ArgTypeInt] to one that can be stored in a [types.Keyword].
func ArgTypeInt(fn func(arg types.PartInt, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToInt(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ArgTypeFloat converts a validator function that accepts
// [types.ArgTypeFloat] to one that can be stored in a [types.Keyword].
func ArgTypeFloat(fn func(arg types.PartFloat, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToFloat(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ArgTypeSchema converts a validator function that accepts
// [types.ArgTypeSchema] to one that can be stored in a [types.Keyword].
func ArgTypeSchema(fn func(arg types.PartSchema, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToSchema(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToSchema converts arg into a [types.PartSchema].
func ToSchema(arg types.PartValue) (types.PartSchema, error) {
	v, ok := arg.(types.PartSchema)
	if !ok {
		var zero types.PartSchema
		return zero, fmt.Errorf("got %T, expect a schema", arg)
	}
	return v, nil
}

// ArgTypeSchemas converts a validator function that accepts
// [types.ArgTypeSchemas] to one that can be stored in a [types.Keyword].
func ArgTypeSchemas(fn func(arg types.PartSchemas, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToSchemas(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToSchemas converts arg into a [types.PartSchemas].
func ToSchemas(arg types.PartValue) (types.PartSchemas, error) {
	v, ok := arg.(types.PartSchemas)
	if !ok {
		var zero types.PartSchemas
		return zero, fmt.Errorf("got %T, expect an array of schemas", arg)
	}
	return v, nil
}

// ArgTypeMapSchema converts a validator function that accepts
// [types.ArgTypeMapSchema] to one that can be stored in a [types.Keyword].
func ArgTypeMapSchema(fn func(arg types.PartMapSchema, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToMapSchema(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToMapSchema converts arg into a [types.PartMapSchema].
func ToMapSchema(arg types.PartValue) (types.PartMapSchema, error) {
	v, ok := arg.(types.PartMapSchema)
	if !ok {
		var zero types.PartMapSchema
		return zero, fmt.Errorf("got %T, expect a mapping from strings to schemas", arg)
	}
	return v, nil
}

// ArgTypeSchemaOrSchemas converts a validator function that accepts
// [types.ArgTypeSchemaOrSchemas] to one that can be stored in a [types.Keyword].
func ArgTypeSchemaOrSchemas(fn func(arg types.PartSchemaOrSchemas, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToSchemaOrSchemas(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToSchemaOrSchemas converts arg into a [types.PartSchemaOrSchemas].
func ToSchemaOrSchemas(arg types.PartValue) (types.PartSchemaOrSchemas, error) {
	v, ok := arg.(types.PartSchemaOrSchemas)
	if !ok {
		var zero types.PartSchemaOrSchemas
		return zero, fmt.Errorf("got %T, expect a single schema or an array of schemas", arg)
	}
	return v, nil
}

// ArgTypeMapArrayOrSchema converts a validator function that accepts
// [types.ArgTypeMapArrayOrSchema] to one that can be stored in a [types.Keyword].
func ArgTypeMapArrayOrSchema(fn func(arg types.PartMapArrayOrSchema, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToMapArrayOrSchema(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToMapArrayOrSchema converts arg into a [types.PartMapArrayOrSchema].
func ToMapArrayOrSchema(arg types.PartValue) (types.PartMapArrayOrSchema, error) {
	v, ok := arg.(types.PartMapArrayOrSchema)
	if !ok {
		var zero types.PartMapArrayOrSchema
		return zero, fmt.Errorf("got %T, expect a mapping from strings to either a schema or an array of strings", arg)
	}
	return v, nil
}

// ArgTypeAny converts a validator function that accepts
// [types.ArgTypeAny] to one that can be stored in a [types.Keyword].
func ArgTypeAny(fn func(arg types.PartAny, instance any, state *types.ValidationState) error) func(types.PartValue, any, *types.ValidationState) error {
	return func(arg types.PartValue, instance any, state *types.ValidationState) error {
		v, err := ToAny(arg)
		if err != nil {
			return err
		}
		return fn(v, instance, state)
	}
}

// ToAny converts arg into a [types.PartAny].
func ToAny(arg types.PartValue) (types.PartAny, error) {
	v, ok := arg.(types.PartAny)
	if !ok {
		var zero types.PartAny
		return zero, fmt.Errorf("got %T, expect any type", arg)
	}
	return v, nil
}
